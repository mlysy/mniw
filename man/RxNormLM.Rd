% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/Hierarchical.R
\name{RxNormLM}
\alias{RxNormLM}
\title{Bayesian inference for a random-effects regression model.}
\usage{
RxNormLM(nsamples, Y, V, X, prior = NULL, init, burn, updateHyp = TRUE,
  storeHyp = TRUE, updateRX = TRUE, storeRX = FALSE)
}
\arguments{
\item{nsamples}{number of posterior samples to draw.}

\item{Y}{\code{N x q} matrix of responses.}

\item{V}{Either a \code{q x q} variance matrix or an \code{q x q x N} array of such matrices.}

\item{X}{\code{N x p} matrix of covariates.}

\item{prior}{parameters of the prior MNIW distribution on the hyperparameters (see \strong{Details}).}

\item{init}{(optional) list with elements \code{Beta}, \code{Sigma}, and \code{Mu} providing the initial values for these.  Default values are \code{Beta = matrix(0, p, q)}, \code{Sigma = diag(q)}, and \code{Mu = Y}.}

\item{burn}{integer number of burn-in samples, or fraction of \code{nsamples} to prepend as burn-in.}

\item{updateHyp, storeHyp}{logical. Whether or not to update/store the hyperparameter draws.}

\item{updateRX, storeRX}{logical. Whether or not to update/store the random-effects draws.}
}
\value{
A list with (potential) elements:
\describe{
  \item{\code{Beta}}{An \code{p x q x nsamples} array of regression coefficient iterations (if \code{storeHyp == TRUE})}
  \item{\code{Sigma}}{An \code{q x q x nsamples} array of regression variance matrices (if \code{storeHyp == TRUE})}
  \item{\code{Mu}}{An \code{n x q x nsamples} array of random effects (if \code{storeRX == TRUE})}
}
}
\description{
Gibbs sampler for posterior distribution of parameters and hyperparameters of a multivariate normal random-effects linear regression model called RxNormLM (see \strong{Details}).
}
\details{
The RxNormLM model is given by
\deqn{
y_i \mid \mu_i \sim_iid N(\mu_i, V_i)
}
\deqn{
\mu_i \mid \beta, \Sigma ~sim_ind N(x_i' \beta, \Sigma)
}
\deqn{
\beta, \Sigma ~ MNIW(\Lambda, \Omega^{-1}, \Psi, \nu),
}
where \eqn{y_i} and \eqn{\mu_i} are response and random-effects vectors of length \eqn{q}, \eqn{x_i} are covariate vectors of length \eqn{p}, and \eqn{(\beta, \Sigma)} are hyperparameter matrices of size \eqn{p \times q} and \eqn{q \times q}.

The MNIW prior distribution is given by a list with elements \code{Lambda}, \code{Omega}, \code{Psi}, and \code{nu}.  If any of these is \code{NULL} or missing, the default value is 0.  Note that \code{Omega == 0} gives a Lebesgue prior to \eqn{\beta}.
}
\examples{
# Input Specifications
nsamples <- 10
N <- 20
p <- 1
q <- 2
# prior specification
Lambda0 <- rMNorm(1, Lambda = matrix(0, p, q))
Omega0 <- crossprod(rMNorm(1, Lambda = matrix(0, p, p)))
Psi0 <- crossprod(rMNorm(1, Lambda = matrix(0, q, q)))
nu0 <- rexp(1) + (q+1)
# covariate specification
X <- rMNorm(1, matrix(0, N, p))
V <- array(rwish(N, diag(q), q+1),dim=c(q,q,N))

# generate response data
Sigma00 <- rwish(1, Psi0, nu0)
Beta00 <- rMNorm(1, Lambda0, Omega0, Sigma00)
Mu00 <- rmNorm(N, X \%*\% Beta00, Sigma00) # random effects
Y00 <- rmNorm(N, Mu00, V) # Data

# Gibbs sampling to get posterior
prior_list <- list(Psi=Psi0, Lambda=Lambda0, Omega=solve(Omega0), nu=nu0) # Prior
init_list <- list(Beta=Beta00,Sigma=Sigma00,Mu=Mu00) # Initialize MCMC
r_fit <- RxNormLM(nsamples, Y=Y00, V=V, X=X,
                  prior = prior_list,
                  init = init_list,
                  burn = ceiling(nsamples/2))
}
